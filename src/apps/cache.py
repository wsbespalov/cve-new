import os
import sys
import json
import datetime

runPath = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(runPath, ".."))

import redis

from settings.settings import Settings

def correct_types(task):
    data = task['data']
    if isinstance(data, list):
        for every in data:
            if isinstance(every, dict):
                for key in every.keys():
                    if type(every[key]) == type(datetime.datetime.now()):
                        o = every[key]
                        tt = o.strftime('%Y-%m-%dT%H:%M:%S.%f%zZ')
                        every[key] = tt
                    if type(every[key]) == type('s'):
                        every[key] = every[key].replace('"', '')
    if isinstance(data, dict):
        for key in data.keys():
            if type(data[key]) == type(datetime.datetime.now()):
                o = data[key]
                tt = o.strftime('%Y-%m-%dT%H:%M:%S.%f%zZ')
                data[key] = tt
            if type(data[key]) == type('s'):
                data[key] = data[key].replace('"', '')
    if type(data) == type(datetime.datetime.now()):
        data = data.strftime('%Y-%m-%dT%H:%M:%S.%f%zZ')
    task['data'] = data
    return task


class Cache():
    def __init__(self):
        st = Settings()
        self.settings = st.load()
        self.host = self.settings['redis_host']
        self.port = self.settings['redis_port']
        self.db = redis.StrictRedis(
            host=self.host,
            port=self.port,
            charset="utf-8",
            decode_responses=True
        )
        self.collection_tasks = self.settings['redis_collection_name'] + ':' + self.settings['redis_collection_tasks']
        self.collection_cve = self.settings['redis_collection_name'] + ':' + self.settings['redis_collection_cve']
        self.collection_cpe = self.settings['redis_collection_name'] + ':' + self.settings['redis_collection_cpe']
        self.collection_cwe = self.settings['redis_collection_name'] + ':' + self.settings['redis_collection_cwe']
        self.collection_cpeother = self.settings['redis_collection_name'] + ':' + self.settings['redis_collection_cpeother']
        self.collection_whitelist = self.settings['redis_collection_name'] + ':' + self.settings['redis_collection_whitelist']
        self.collection_blacklist = self.settings['redis_collection_name'] + ':' + self.settings['redis_collection_blacklist']
        self.collection_info = self.settings['redis_collection_name'] + ':' + self.settings['redis_collection_info']
        self.collection_ranking = self.settings['redis_collection_name'] + ':' + self.settings['redis_collection_ranking']
        self.collection_via4 = self.settings['redis_collection_name'] + ':' + self.settings['redis_collection_via4']
        self.collection_capec = self.settings['redis_collection_name'] + ':' + self.settings['redis_collection_capec']
        self.complete_flag = self.settings['redis_complete_flag']

    def connected(self):
        try:
            self.db.get(None)
        except (redis.ConnectionError, redis.BusyLoadingError):
            return False
        return True

    def set_complete_flag(self):
        if self.connected():
            self.db.set(self.complete_flag, True)

    def empty_tasks(self):
        if self.connected():
            return self.db.llen(self.collection_tasks) == 0
        return True

    def get_last_task(self):
        if self.connected():
            raw_task = self.db.lrange(
                self.collection_tasks,
                0,
                0
            )
            raw_task_ = raw_task[0]
            return raw_task_
        return None

    def delete_last_task(self):
        if self.connected():
            self.db.lpop(
                self.collection_tasks
            )

    def push_item(self, item, collection):
        if self.connected():
            return self.db.rpush(
                collection,
                json.dumps(item)
            )
        return None

    def pop_item(self, collection):
        if self.connected():
            return json.loads(self.db.lpop(collection))
        return None

    def push_task(self, task):
        if self.connected():
            task = correct_types(task)
            self.db.rpush(
                self.collection_tasks,
                task
            )
        return None

    def pop_task(self):
        if self.connected():
            if self.db.llen(self.collection_tasks) > 0:
                return json.loads(
                    self.db.lpop(
                        self.collection_tasks
                ))
        return None
