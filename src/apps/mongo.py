import re
import os
import sys
runPath = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(runPath, ".."))

from pymongo import MongoClient
from pymongo import cursor
from pymongo.errors import ConnectionFailure

from settings.settings import Settings
st = Settings()

def sanitize(x):
    if type(x) == cursor.Cursor:
        x = list(x)
    if type(x) == list:
        for y in x: sanitize(y)
    if x and  "_id" in x:
        x.pop("_id")
    return x

class Mongo():

    def __init__(self):
        self.settings = st.load()
        self.host = self.settings['mongo_host']
        self.port = self.settings['mongo_port']
        self.username = self.settings['mongo_username']
        self.password = self.settings['mongo_password']
        self.db_name = self.settings['mongo_db']
        try:
            self.connection = MongoClient(
                self.host,
                self.port,
                # connect=False
            )
            self.db = self.connection[self.db_name]
        except ConnectionFailure:
            self.db = None
        self.collection_cve = self.db['cves'] if self.db is not None else None
        self.collection_cpe = self.db['cpe'] if self.db is not None else None
        self.collection_cwe = self.db['cwe'] if self.db is not None else None
        self.collection_cpeother = self.db['cpeother'] if self.db is not None else None
        self.collection_whitelist = self.db['whitelist'] if self.db is not None else None
        self.collection_blacklist = self.db['blacklist'] if self.db is not None else None
        self.collection_info = self.db['info'] if self.db is not None else None
        self.collection_ranking = self.db['ranking'] if self.db is not None else None
        self.collection_via4 = self.db['via4'] if self.db is not None else None
        self.collection_capec = self.db['capec'] if self.db is not None else None

    def nbelement(self, collection=None):
        if collection is None or collection == "cve":
            collection = "cves"
        return self.db.getSize(collection)

    def ensureIndex(self, col, field):
        self.db[col].ensure_index(field)

    def drop(self, col):
        self.db[col].drop()

    def setColUpdate(self, collection, date):
        self.collection_info.update(
            {"db": collection},
            {"$set": {
                "last-modified": date}},
            upsert=True)

    def setColInfo(self, collection, field, data):
        self.collection_info.update(
            {"db": collection},
            {"$set": {
                field: data}},
            upsert=True)

    def insertCVE(self, cve):
        self.collection_cve.insert(cve)

    def updateCVE(self, cve):
        self.collection_cve.update(
            {"id": cve['id']},
            {"$set": {
                "cvss": cve['cvss'],
                "summary": cve['summary'],
                "references": cve['references'],
                "cwe": cve['cwe'],
                "vulnerable_configuration": cve['vulnerable_configuration'],
                "vulnerable_configuration_cpe_2_2": cve['vulnerable_configuration_cpe_2_2'],
                'last-modified': cve['Modified']}})

    def bulkUpdate(self, collection, data):
        if len(data) > 0:
            bulk = self.db[collection].initialize_unordered_bulk_op()
            for x in data:
                bulk.find(
                    {'id': x['id']}).upsert().update({'$set': x})
            bulk.execute()

    def cpeotherBulkInsert(self, cpeotherlist):
        self.collection_cpeother.insert(cpeotherlist)

    def dropCollection(self, col):
        return self.db[col].drop()

    def getTableNames(self):
        return self.db.collection_names()

    def cvesForCPE(self, cpe):
        if not cpe:
            return []
        return sanitize(
            self.collection_cve.find(
                {"vulnerable_configuration": {
                    "$regex": cpe}}).sort("Modified", -1))

    def getCVEs(self, limit=False, query=None, skip=0, cves=None, collection=None):
        if query is None:
            query = []
        col = self.collection_cve if not collection else self.db[collection]
        if type(query) == dict:
            query = [query]
        if type(cves) == list:
            query.append({"id": {"$in": cves}})
        if len(query) == 0:
            cve = col.find().sort("Modified", -1).limit(limit).skip(skip)
        elif len(query) == 1:
            cve = col.find(query[0]).sort("Modified", -1).limit(limit).skip(skip)
        else:
            cve = col.find({"$and": query}).sort("Modified", -1).limit(limit).skip(skip)
        return sanitize(cve)

    def getCVEsNewerThan(self, dt):
        return sanitize(
            self.getCVEs(
                query={'last-modified': {'$gt': dt}}))

    def getCVEIDs(self, limit=-1):
        return [x["id"] for x in self.collection_cve.find().limit(limit).sort("Modified", -1)]

    def getCVE(self, id, collection=None):
        col = self.collection_cve if not collection else self.db[collection]
        return sanitize(col.find_one({"id": id}))

    def getCPE(self, id):
        return sanitize(
            self.collection_cpe.find_one({"id": id}))

    def getCPEs(self):
        return sanitize(
            self.collection_cpe.find())

    def getAlternativeCPE(self, id):
        return sanitize(
            self.collection_cpeother.find_one({"id": id}))

    def getAlternativeCPEs(self):
        return sanitize(
            self.collection_cpeother.find())

    def getVIA4(self, id):
        return sanitize(
            self.collection_via4.find_one({'id': id}))

    def getCPEMatching(self, regex, fullSearch=False):
        lst = list(self.collection_cpe.find({"id": {"$regex": regex}}))
        if fullSearch:
            lst.extend(self.collection_cpe.find({"id": {"$regex": regex}}))
        return lst

    def getFreeText(self, text):
        try:
            return [x["obj"] for x in self.db.command("text", "cves", search=text)["results"]]
        except:
            return sanitize(
                self.collection_cve.find({"$text": {"$search": text}}))

    def getSearchResults(self, search):
        result = {'data': []}
        regSearch = re.compile(re.escape(search), re.I)
        links = {'n': 'Link', 'd': []}
        for vLink in self.getInfo('via4').get('searchables', []):
            links['d'].extend(sanitize(self.collection_via4.find({vLink: {'$in': [regSearch]}})))
        try:
            textsearch = {'n': 'Text search', 'd': self.getFreeText(search)}
        except:
            textsearch = {'n': 'Text search', 'd': []}
            result['errors'] = ['textsearch']
        for collection in [links, textsearch]:
            for item in collection['d']:
                if not any(item['id'] == entry['id'] for entry in result['data']):
                    entry = self.getCVE(item['id'])
                    if entry:
                        entry['reason'] = collection['n']
                        result['data'].append(entry)
        return result

    def getCAPECFor(self, cwe):
        return sanitize(
            self.collection_capec.find({'related_weakness': {'$in': [cwe]}}))

    def getCAPEC(self, cweid):
        return sanitize(
            self.collection_capec.find_one({'id': cweid}))

    def getCWEs(self):
        return sanitize(
            sorted(self.collection_cwe.find(), key=lambda k: int(k['id'])))

    def getInfo(self, collection):
        return sanitize(
            self.collection_info.find_one({"db": collection}))

    def getLastModified(self, collection):
        info = self.getInfo(collection)
        return info['last-modified'] if info else None

    def getSize(self, collection):
        return self.db[collection].count()

    def via4Linked(self, key, val):
        cveList = [x['id'] for x in self.collection_via4.find({key: val})]
        return sanitize(
            self.getCVEs(query={'id': {'$in': cveList}}))

    def getDBStats(self, include_admin=False):
        data = {'cves': {}, 'cpe': {}, 'cpeOther': {}, 'capec': {}, 'cwe': {}, 'via4': {}}
        for key in data.keys():
            data[key] = {
                'size': self.getSize(key.lower()),
                'last_update': self.getLastModified(key.lower())}
        if include_admin:
            data['whitelist'] = {'size': self.collection_whitelist.count()}
            data['blacklist'] = {'size': self.collection_blacklist.count()}
            data = {'stats': {
                'size_on_disk': self.db.command("dbstats")['storageSize'],
                'db_size': self.db.command('dbstats')['dataSize'],
                'name': self.db_name},
                'data': data}
        return data

    def getWhitelist(self):
        return sanitize(
            self.collection_whitelist.find())

    def isInWhitelist(self, cpe):
        return True if self.collection_whitelist.find({'id': cpe}).count() > 0 else False

    def addToWhitelist(self, cpe, type, comments=None):
        if comments:
            self.collection_whitelist.insert(
                {'id': cpe, 'type': type, 'comments': comments})
        else:
            self.collection_whitelist.insert(
                {'id': cpe, 'type': type})

    def removeFromWhitelist(self, cpe):
        self.collection_whitelist.remove(
            {'id': cpe})

    def updateWhitelist(self, oldCPE, newCPE, type, comments=None):
        if comments:
            self.collection_whitelist.update(
                {'id': oldCPE}, {'id': newCPE, 'type': type, 'comments': comments})
        else:
            self.collection_whitelist.update(
                {'id': oldCPE}, {'id': newCPE, 'type': type})

    def getBlacklist(self):
        return sanitize(
            self.collection_blacklist.find())

    def isInBlacklist(self, cpe):
        return True if self.collection_blacklist.find({'id': cpe}).count() > 0 else False

    def addToBlacklist(self, cpe, type, comments=None):
        if comments:
            self.collection_blacklist.insert(
                {'id': cpe, 'type': type, 'comments': comments})
        else:
            self.collection_blacklist.insert(
                {'id': cpe, 'type': type})

    def removeFromBlacklist(self, cpe):
        self.collection_blacklist.remove(
            {'id': cpe})

    def updateBlacklist(self, oldCPE, newCPE, type, comments=None):
        if comments:
            self.collection_blacklist.update(
                {'id': oldCPE}, {'id': newCPE, 'type': type, 'comments': comments})
        else:
            self.collection_blacklist.update(
                {'id': oldCPE}, {'id': newCPE, 'type': type})

    def getRules(self, list):
        if list.lower() == 'whitelist':
            col = self.collection_whitelist
        elif list.lower() == 'blacklist':
            col = self.collection_blacklist
        else:
            return []
        rlist = col.find({'type': 'cpe'}).distinct('id')
        rlist.extend(
            ["cpe:2.3:([^:]*:){9}" + re.escape(x) for x in col.find(
                {'type': 'targethardware'}).distinct('id')])
        rlist.extend(
            ["cpe:2.3:([^:]*:){8}" + re.escape(x) for x in col.find(
                {'type': 'targetsoftware'}).distinct('id')])
        return rlist

    def addRanking(self, cpe, key, rank):
        item = self.findRanking(cpe)
        if item is None:
            self.collection_ranking.update(
                {'cpe': cpe}, {"$push": {'rank': {key: rank}}}, upsert=True)
        else:
            l = []
            for i in item['rank']:
                i[key] = rank
                l.append(i)
                self.collection_ranking.update(
                    {'cpe': cpe}, {"$set": {'rank': l}})
        return True

    def removeRanking(self, cpe):
        return sanitize(
            self.collection_ranking.remove({'cpe': {'$regex': cpe}}))

    def findRanking(self, cpe=None, regex=False):
        if not cpe:
            return sanitize(
                self.collection_ranking.find())
        if regex:
            return sanitize(
                self.collection_ranking.find_one({'cpe': {'$regex': cpe}}))
        else:
            return sanitize(
                self.collection_ranking.find_one({'cpe': cpe}))